<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Máquinas de Turing Universales</title>
<meta name="author" content=""/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="file:///home/carlos/.config/emacs/reveal/reveal.js/dist/reveal.css"/>

<link rel="stylesheet" href="file:///home/carlos/.config/emacs/reveal/reveal.js/dist/theme/solarized.css" id="theme"/>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<style>
.reveal .slides {
width: 100%;
height: 100%;
}
.reveal section {
padding: 20px;
height: auto;
overflow: visible;
}
.reveal h1 {
font-size: 2.0em;
}
.reveal h2 {
font-size: 1.6em;
}
.reveal p, .reveal li {
font-size: 1.1em;
line-height: 1.4;
margin-bottom: 0.5em;
}
.MathJax {
font-size: 100% !important;
}
</style>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1>Máquinas de Turing Universales</h1><p>Carlos Eduardo Moreno Vargas y Joaquín Alfredo Castro Córdova</p>
</section>

<section>
<section id="slide-org6ff10b9">
<h2 id="org6ff10b9">Introducción</h2>
<div class="outline-text-2" id="text-org6ff10b9">
</div>
</section>
<section id="slide-org7343f7d">
<h3 id="org7343f7d">Contexto</h3>
<ul>
<li>Las máquinas de Turing (MT) son modelos matemáticos fundamentales en la teoría de la computación.</li>
<li>Se usan para definir formalmente lo que significa "computar".</li>
<li>Una máquina de Turing universal (MTU) es una MT capaz de simular cualquier otra MT.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgb6c6750">
<h2 id="orgb6c6750">¿Qué es una máquina de Turing?</h2>
<div class="outline-text-2" id="text-orgb6c6750">
</div>
</section>
<section id="slide-org99b8ce0">
<h3 id="org99b8ce0">Definición formal</h3>
<ul>
<li>Formalmente, una máquina de Turing es una 7-tupla:
\[
     M = (Q, \Sigma, \Gamma, \delta, q_0, q_{\text{accept}}, q_{\text{reject}})
     \]</li>

</ul>

</section>
<section id="slide-org0829228">
<h3 id="org0829228">Componentes (I)</h3>
<ul>
<li>\( Q \): conjunto finito de estados</li>
<li>\( \Sigma \): alfabeto de entrada (no incluye el blanco)</li>
<li>\( \Gamma \): alfabeto de la cinta (incluye el símbolo blanco)</li>
<li>\( \delta \): función de transición \( \delta : Q \times \Gamma \rightarrow Q \times \Gamma \times \{L, R\} \)</li>

</ul>

</section>
<section id="slide-org69a2a24">
<h3 id="org69a2a24">Componentes (II)</h3>
<ul>
<li>\( q_0 \in Q \): estado inicial</li>
<li>\( q_{\text{accept}}, q_{\text{reject}} \in Q \): estados de aceptación y rechazo</li>

</ul>

</section>
<section id="slide-org62bc793">
<h3 id="org62bc793">Comparación con autómatas</h3>
<ul>
<li>Memoria infinita (la cinta).</li>
<li>Cabezal que se mueve en ambas direcciones.</li>
<li>Capacidad de escribir en la cinta.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orge9d5c7f">
<h2 id="orge9d5c7f">¿Qué es una máquina de Turing universal?</h2>
<div class="outline-text-2" id="text-orge9d5c7f">
</div>
</section>
<section id="slide-orgbb61a9f">
<h3 id="orgbb61a9f">Definición</h3>
<ul>
<li>Una MTU es capaz de simular cualquier otra máquina de Turing.</li>

</ul>

</section>
<section id="slide-orgc659e1b">
<h3 id="orgc659e1b">Notación de simulación</h3>
<ul>
<li>Dada la codificación \( \langle M, w \rangle \), la MTU simula la ejecución de \( M \) sobre \( w \):
\[
     U(\langle M, w \rangle) \rightarrow M(w)
     \]</li>

</ul>

</section>
</section>
<section>
<section id="slide-org7746086">
<h2 id="org7746086">Lenguaje universal</h2>
<div class="outline-text-2" id="text-org7746086">
</div>
</section>
<section id="slide-org5c5fb9b">
<h3 id="org5c5fb9b">Definición</h3>
<ul>
<li>El lenguaje universal \( L_{uni} \) es el conjunto de cadenas binarias de la forma \( w_M 111 y \), donde:
<ul>
<li>\( w_M \) es la codificación binaria de una máquina \( M \).</li>
<li>\( y \) es una cadena binaria en \( L(M) \), el conjunto de cadenas aceptadas por \( M \).</li>

</ul></li>

</ul>

</section>
<section id="slide-org963f9b5">
<h3 id="org963f9b5">Características</h3>
<ul>
<li>Los tres unos consecutivos ('111') sirven para separar la codificación de la máquina \( w_M \) de la entrada \( y \).</li>
<li>El lenguaje universal es:
\[
     L_{uni} = \{ w_M 111 y \mid y \in L(M) \}
     \]</li>

</ul>

</section>
<section id="slide-orgf5c108a">
<h3 id="orgf5c108a">Propiedad</h3>
<ul>
<li>Existe una MTU tal que:
\[
     L(M_{uni}) = L_{uni}
     \]</li>

</ul>

</section>
</section>
<section>
<section id="slide-org2306996">
<h2 id="org2306996">Simulación de máquinas: estructura de Muni</h2>
<div class="outline-text-2" id="text-org2306996">
</div>
</section>
<section id="slide-orgecd7d30">
<h3 id="orgecd7d30">Vista general</h3>
<ul>
<li>Muni puede verse como una máquina de 4 cintas.</li>

</ul>

</section>
<section id="slide-org0c70cfe">
<h3 id="org0c70cfe">Cinta 1: Entrada</h3>
<ul>
<li>Contiene \( w_M111y \).</li>
<li>Esta cinta no se modifica durante la simulación.</li>
<li>Sirve como referencia constante para la MT original y su entrada.</li>

</ul>

</section>
<section id="slide-org17ff390">
<h3 id="org17ff390">Cinta 2: Cinta de simulación</h3>
<ul>
<li>Simula la cinta de la máquina \( M \).</li>
<li>Cada símbolo se representa como una cadena de ceros: \( 0^i \).</li>
<li>Los símbolos están separados entre sí por un 1.</li>
<li>Ejemplo de contenido: \( 0^1 \,1\, 0^3 \,1\, 0^2 \) para representar tres símbolos codificados.</li>

</ul>

</section>
<section id="slide-org4f056c0">
<h3 id="org4f056c0">Cinta 3: Cinta de estados</h3>
<ul>
<li>Representa el estado actual de la máquina \( M \).</li>
<li>Se codifica como una cadena de ceros \( 0^k \), donde \( k \) es el número asociado al estado.</li>
<li>Esta cinta se actualiza con cada transición.</li>

</ul>

</section>
<section id="slide-org4bef9bf">
<h3 id="org4bef9bf">Cinta 4: Cinta auxiliar</h3>
<ul>
<li>Se usa para cálculos internos y para hacer <b>shifting</b> (desplazamiento de símbolos).</li>
<li>Es fundamental para preservar la integridad de la cinta simulada cuando se necesita mover el cabezal o insertar blancos.</li>

</ul>

</section>
</section>
<section>
<section id="slide-orgaf26701">
<h2 id="orgaf26701">Tareas principales de Muni</h2>
<div class="outline-text-2" id="text-orgaf26701">
</div>
</section>
<section id="slide-org63fc873">
<h3 id="org63fc873">1. Validación de \( w_M \)</h3>
<ul>
<li>Verifica que \( w_M \) codifica una MT válida. Si no es válida, Muni rechaza.</li>

</ul>

</section>
<section id="slide-org3ccd653">
<h3 id="org3ccd653">2. Codificación de la entrada \( y \)</h3>
<ul>
<li>\( 0 \rightarrow 10 \)</li>
<li>\( 1 \rightarrow 100 \)</li>
<li>Blanco \( \rightarrow 1000 \)</li>

</ul>

</section>
<section id="slide-org6229d91">
<h3 id="org6229d91">3. Estado inicial</h3>
<ul>
<li>Se escribe la codificación de \( q_0 \) como \( 0 \).</li>

</ul>

</section>
<section id="slide-org8fc66b1">
<h3 id="org8fc66b1">4. Simulación de transiciones</h3>
<ul>
<li>Muni busca en la cinta de definición una transición:
\[
     0^i \, 10^j \, 10^k \, 10^l \, 10^m
     \]</li>

</ul>

</section>
<section id="slide-org7e06ffa">
<h3 id="org7e06ffa">Explicación de la transición</h3>
<ul>
<li>Interpreta:
<ul>
<li>\( 0^i \): estado actual.</li>
<li>\( 0^j \): símbolo leído.</li>
<li>\( 0^k \): nuevo estado.</li>
<li>\( 0^l \): nuevo símbolo.</li>
<li>\( 0^m \): dirección (1 → derecha, 2 → izquierda).</li>

</ul></li>

</ul>

</section>
<section id="slide-org9486938">
<h3 id="org9486938">Cinta auxiliar</h3>
<ul>
<li>Se usa para hacer shifting al mover el escáner.</li>
<li>Mantiene la integridad de la simulación.</li>
<li>Es esencial para cambios de símbolos o insertar blancos.</li>

</ul>

</section>
<section id="slide-org054a336">
<h3 id="org054a336">Condiciones de aceptación</h3>
<ul>
<li>Si \( 0^k \in F_M \), Muni acepta.</li>
<li>Si no hay transición definida en \( (0^k, 0^n) \), Muni se detiene sin aceptar.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org981cdbd">
<h2 id="org981cdbd">Consecuencias teóricas</h2>
<div class="outline-text-2" id="text-org981cdbd">
</div>
</section>
<section id="slide-orgce786bb">
<h3 id="orgce786bb">Teorema</h3>
<ul>
<li>El lenguaje universal \( L_{uni} \) es <b>recursivamente enumerable</b> pero <b>no recursivo</b>.</li>

</ul>

</section>
<section id="slide-org8314e5c">
<h3 id="org8314e5c">Demostración por contradicción</h3>
<ol>
<li>Si fuera recursivo, su complemento también lo sería.</li>
<li>Se podría construir una MT que decida el problema de la parada.</li>
<li>Esto lleva a una contradicción lógica (construcción de \( M_{\text{absurd}} \)).</li>

</ol>

</section>
</section>
<section>
<section id="slide-orgcae4814">
<h2 id="orgcae4814">El problema de la parada</h2>
<div class="outline-text-2" id="text-orgcae4814">
</div>
</section>
<section id="slide-org61bc3bc">
<h3 id="org61bc3bc">Definición</h3>
<ul>
<li>\( L_{\text{halt}} = \{ w111y \mid M_w \text{ se detiene con entrada } y \} \)</li>

</ul>

</section>
<section id="slide-org26878de">
<h3 id="org26878de">Suposición</h3>
<ul>
<li><p>
Supongamos que existe una MT que lo decide, \( M_{\text{halt}} \). Se puede construir:
\[
M<sub>\text{absurd}</sub>(w) =
</p>
<div>
\begin{cases}
\text{loop}, & \text{si } M_{\text{halt}}(w111w) = \text{true} \\
\text{acepta}, & \text{si } M_{\text{halt}}(w111w) = \text{false}
\end{cases}

</div>
<p>
\]
</p></li>

</ul>

</section>
<section id="slide-org2d9a6bf">
<h3 id="org2d9a6bf">Contradicción</h3>
<ul>
<li>Esto lleva a una contradicción al evaluar \( M_{\text{absurd}}(w_{\text{absurd}}) \).</li>
<li>Por lo tanto, el problema de la parada es indecidible.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org0326a01">
<h2 id="org0326a01">Conclusiones</h2>
<div class="outline-text-2" id="text-org0326a01">
</div>
</section>
<section id="slide-orgc6f5059">
<h3 id="orgc6f5059">Ideas clave</h3>
<ul>
<li>Las MTU son fundamentales para la computación moderna.</li>
<li>Toda computadora real es una implementación práctica de una MTU.</li>
<li>La existencia de problemas indecidibles es una de las consecuencias más profundas de la teoría de la computación.</li>

</ul>

</section>
</section>
<section>
<section id="slide-org09e5fa2">
<h2 id="org09e5fa2">Gracias</h2>
</section>
</section>
</div>
</div>
<script src="/home/carlos/.config/emacs/reveal/reveal.js/dist/reveal.js"></script>
<script src="file:///home/carlos/.config/emacs/reveal/reveal.js/plugin/markdown/markdown.js"></script>
<script src="file:///home/carlos/.config/emacs/reveal/reveal.js/plugin/zoom/zoom.js"></script>
<script src="file:///home/carlos/.config/emacs/reveal/reveal.js/plugin/notes/notes.js"></script>


<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
plugins: [RevealMarkdown, RevealZoom, RevealNotes]
});

</script>
</body>
</html>
